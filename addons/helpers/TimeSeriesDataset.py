import numpy as np
class TimeSeriesDatasetIterator:
    def __init__(self, dataset):
        self._dataset = dataset
        self._index = 0

    def __next__(self):
        if self._index < len(self._dataset):
            return self._dataset[self._index]
        else:
            raise StopIteration

class TimeSeriesDatasetXY:
    def __init__(self, timeseries_dataset):
        """
        timeseries_dataset - tuple containing 2 instances of TimeSeriesDataset
        """
        self._timeseries_dataset = timeseries_dataset

    @property
    def x(self):
        return self._timeseries_dataset[0]

    @property
    def y(self):
        return self._timeseries_dataset[0]

    def __repr__(self):
        return f"TimeSeriesDatasetXY(X:{self._timeseries_dataset[0]}, Y:{self._timeseries_dataset[1]})"

    def numpy(self, batch=None):
        return tuple([d.numpy(batch=batch) for d in self._timeseries_dataset])

    def tensorflow_numpy(self, batch=None):
        return tuple([d.tensorflow_numpy(batch=batch) for d in self._timeseries_dataset])

    def __getitem__(self, item):
        # returns batch = array of timestamps
        return tuple([d[item] for d in self._timeseries_dataset])


class TimeSeriesDataset:
    def __init__(self, dataset, name=""):
        """
        TimeSeriesDataset is a wrapper class for dataset generated by TimeSeries object. These dataset has following format:
        for i, batch in enumerate(dataset):
             print(f"batch size {len(batch)}")
             for ts in batch:
                 print(f" - ts: {len(ts)}")
        in simple words: dataset is a list of batches. Each batch is a list of datasamples which are TS objects. It is
        2D array of TS.
        """
        self._name = ""
        self.validate(dataset)
        self._dataset = dataset

    def validate(self, dataset):
        is_valid = True
        #check emptiness
        if len(dataset) == 0:
            raise RuntimeError(f"TimeSeriesDataset.validate {self._name} dataset inconsistent detected: Empty dataset")
        if len(dataset[0]) == 0:
            raise RuntimeError(f"TimeSeriesDataset.validate {self._name} dataset inconsistent detected: First batch empty")
        if len(dataset[0][0]) == 0:
            raise RuntimeError(f"TimeSeriesDataset.validate {self._name} dataset inconsistent detected: First TS empty")

        # check equality of batches length
        if any([len(batch) != len(dataset[0]) for i,batch in enumerate(dataset)]):
                raise RuntimeError(f"TimeSeriesDataset.validate {self._name} dataset inconsistent detected: Batches not "
                                   f"equals. ")

        # check ts equality
        ts0l = len(dataset[0][0])
        # print([len(ts) for i,batch in enumerate(dataset) for ts in batch])
        # print([len(ts) == ts0l for i,batch in enumerate(dataset) for ts in batch])
        d=[len(ts) != ts0l for i,batch in enumerate(dataset) for ts in batch]
        #print(ts0l, any(d), len(d))


        if any([len(ts) != ts0l for i,batch in enumerate(dataset) for ts in batch]):
                raise RuntimeError(f"TimeSeriesDataset.validate {self._name} dataset inconsistent detected: Batches not "
                                   f"equals. ")

    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, n):
        self._name = n

    def valid(self):
        pass

    @property
    def shape(self):
        shape = [len(self._dataset), len(self._dataset[0]), len(self._dataset[0][0])]
        # shape.append(len(self._dataset))  # batches
        # shape.append(self._dataset[0])  # (TS count per batch)
        # shape.append(self._dataset[0][0])  # TS len = window_size
        return tuple(shape)

    def __iter__(self):
        return TimeSeriesDatasetIterator(self)

    def __len__(self):
        return len(self._dataset)

    def __getitem__(self, item):
        # name_addon = ""
        # if isinstance(arg, slice):
        #     al = [
        #         str(arg.start) if arg.start is not None else "",
        #         str(arg.stop) if arg.stop is not None else "",
        #         str(arg.step) if arg.step is not None else "",
        #     ]
        #     name_addon = "[" + ":".join(al) + "]"
        #     return self._dataset[item]
        # if isinstance(arg, Number):
        ##########################################3
        # returns batch = array of timestamps
        return self._dataset[item]

    def numpy(self, batch=None):
        """
        Function transforms dataset of specified format (constructor) into numpy
        """
        if batch is not None:
            return np.array([ts.data for ts in self._dataset[batch]])
        else:
            return np.array([[ts.data for ts in batch] for batch in self._dataset])

    def tensorflow_numpy(self, batch=None):
        """
        Function transforms dataset of specified format (constructor) into type suitable for Tensorflow LSTM.
        The difference is in shape: TimeSeriesDataset : (449, 64, 10) -> (449, 64, 10, 1). One more dimension is added.
        batch - if batch specified then only one batch is returned. otherwise, all are returned
        """
        if batch is not None:
            return np.array([ts.data.reshape(-1, 1) for ts in self._dataset[batch]])
        else:
            return np.array([[ts.data.reshape(-1,1) for ts in batch] for batch in self._dataset])

    def __repr__(self):
        return f"TimeSeriesDataset {self._name}: {self.shape}"